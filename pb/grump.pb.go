// Code generated by protoc-gen-go.
// source: grump.proto
// DO NOT EDIT!

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	grump.proto

It has these top-level messages:
	Header
	Chunk
	PrivateKey
	EncryptedData
*/
package pb

import proto "code.google.com/p/goprotobuf/proto"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

// The header is the first structure in a Grump message, and contains a set of
// keys--one for each recipient.
//
// The recipients of a message are not identified in the metadata. To decrypt a
// session key, the recipients must iterate through the keys and try decrypting
// each of them. Unused, random keys may be added to this set to confound
// additional metadata analysis.
type Header struct {
	// Each recipient has a copy of the message key, encrypted with
	// ChaCha20Poly1305, using the SHA-256 hash of the Curve25519 ECDH key shared
	// by the receipient and the author of the message as the key.
	Keys             []*EncryptedData `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}

func (m *Header) GetKeys() []*EncryptedData {
	if m != nil {
		return m.Keys
	}
	return nil
}

// The remaining portion of the message consists of chunks, which are
// sequentially-numbered portions of the original message. Each is encrypted
// with ChaCha20Poly1305, using the message key and a unique nonce.
//
// The chunk IDs which have already been writte (including the current chunk ID)
// are serialized in order (i.e., for chunk #4: [1, 2, 3, 4]) as 32-bit
// little-endian integers (i.e. for chunk #2: [0x01, 0x00, 0x00, 0x00, 0x02,
// 0x00, 0x00, 0x00]) and used as the authenticated data for each chunk.
//
// The last chunk includes a final zero ID in its authenticated data to prevent
// tampering.
type Chunk struct {
	Id               *uint32        `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	Data             *EncryptedData `protobuf:"bytes,2,req,name=data" json:"data,omitempty"`
	Last             *bool          `protobuf:"varint,3,req,name=last" json:"last,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Chunk) Reset()         { *m = Chunk{} }
func (m *Chunk) String() string { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()    {}

func (m *Chunk) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Chunk) GetData() *EncryptedData {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Chunk) GetLast() bool {
	if m != nil && m.Last != nil {
		return *m.Last
	}
	return false
}

// Private keys are stored encrypted with a ChaCha20Poly1305 key derived via
// scrypt from a passphrase.
type PrivateKey struct {
	N                *uint64        `protobuf:"varint,1,req" json:"N,omitempty"`
	R                *uint64        `protobuf:"varint,2,req,name=r" json:"r,omitempty"`
	P                *uint64        `protobuf:"varint,3,req,name=p" json:"p,omitempty"`
	Salt             []byte         `protobuf:"bytes,4,req,name=salt" json:"salt,omitempty"`
	Key              *EncryptedData `protobuf:"bytes,5,req,name=key" json:"key,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *PrivateKey) Reset()         { *m = PrivateKey{} }
func (m *PrivateKey) String() string { return proto.CompactTextString(m) }
func (*PrivateKey) ProtoMessage()    {}

func (m *PrivateKey) GetN() uint64 {
	if m != nil && m.N != nil {
		return *m.N
	}
	return 0
}

func (m *PrivateKey) GetR() uint64 {
	if m != nil && m.R != nil {
		return *m.R
	}
	return 0
}

func (m *PrivateKey) GetP() uint64 {
	if m != nil && m.P != nil {
		return *m.P
	}
	return 0
}

func (m *PrivateKey) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

func (m *PrivateKey) GetKey() *EncryptedData {
	if m != nil {
		return m.Key
	}
	return nil
}

// Data encrypted with ChaCha290Poly1305.
type EncryptedData struct {
	Nonce            []byte `protobuf:"bytes,1,req,name=nonce" json:"nonce,omitempty"`
	Ciphertext       []byte `protobuf:"bytes,2,req,name=ciphertext" json:"ciphertext,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EncryptedData) Reset()         { *m = EncryptedData{} }
func (m *EncryptedData) String() string { return proto.CompactTextString(m) }
func (*EncryptedData) ProtoMessage()    {}

func (m *EncryptedData) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *EncryptedData) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func init() {
}
